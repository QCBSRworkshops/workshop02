<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Atelier 2: Charger et manipuler des donn√©es</title>
    <meta charset="utf-8" />
    <meta name="author" content="Centre de la science de la biodiversit√© du Qu√©bec" />
    <link href="assets/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css">
    <link rel="stylesheet" href="qcbsR.css" type="text/css" />
    <link rel="stylesheet" href="qcbsR-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Atelier 2: Charger et manipuler des donn√©es
## S√©rie d‚Äôateliers R du CSBQ
### Centre de la science de la biodiversit√© du Qu√©bec

---




class: inverse, center, middle



# √Ä propos de cet atelier

[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=repo&amp;message=dev&amp;color=6f42c1&amp;logo=github)](https://github.com/QCBSRworkshops/workshop02)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=wiki&amp;message=02&amp;logo=wikipedia)](https://wiki.qcbs.ca/r_workshop2)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=Slides&amp;message=02&amp;color=red&amp;logo=html5)](https://qcbsrworkshops.github.io/workshop02/workshop02-en/workshop02-en.html)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=Slides&amp;message=02&amp;color=red&amp;logo=adobe-acrobat-reader)](https://qcbsrworkshops.github.io/workshop02/workshop02-en/workshop02-en.pdf)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=script&amp;message=02&amp;color=2a50b8&amp;logo=r)](https://qcbsrworkshops.github.io/workshop02/workshop02-en/workshop02-en.R)

---

# Packages requis

* [dplyr](https://cran.r-project.org/package=dplyr)
* [tidyr](https://cran.r-project.org/package=tidyr)
* [magrittr](https://cran.r-project.org/package=magrittr)

&lt;br&gt;

```R
install.packages(c('dplyr', 'tidyr', 'magrittr'))
```
---

# Objectifs d'apprentissage

&lt;br&gt;
##### 1. Cr√©er un projet RStudio
##### 2. √âcrire un script dans R
##### 3. Charger, explorer et enregistrer des donn√©es
##### 4. Manipuler des jeux de donn√©es avec `tidyr`, `dplyr`, `maggritr`


---
class: inverse, center, middle

# Cr√©er un projet RStudio

&lt;hr&gt;

---
# Les projets RStudio

* Qu'est-ce qu'un projet RStudio ?
  - Les projets RStudio permettent l'organisation de son travail et l'acc√®s facile √† tous les fichiers requis pour une analyse.
  - Tous les fichiers, scripts, et documentation utilis√©s pour une analyse sont reli√©s ensemble dans un m√™me projet par un fichier *.Rproj*.

* L'utilisation de projets RStudio facilite la **reproducibilit√©** et le partage de donn√©es, de scripts, et de leur documentation.

---
# Cr√©er un projet dans RStudio

Pour cr√©er un projet dans RStudio, allez dans le menu Fichier puis s√©lectionnez **Nouveau projet** (*File* -&gt; *New Project*).

.center[
![:scale 60%](images/0_Create_a_new_project.png)]

---
# Un projet = un dossier

Organisez vos fichiers !

.center[
![:scale 60%](images/0_folderData1.png)]


---
# Pr√©parer des donn√©es pour l'importation dans R

* Vous devriez enregistrer les fichiers √† importer dans R en tant que fichiers "*comma separated values*" (**.csv**)
* Les fichiers .csv peuvent √™tre cr√©√©s par presque toutes les applications (Excel, GoogleDocs, LibreOffice, etc.)
* Fichier -&gt; Enregistrer sous **.csv**‚Ä¶

.center[
![:scale 45%](images/Excel_csv_good_bad/excel_vs_csv.png)
]



---
# Bien nommer les fichiers

√âvitez d‚Äôutiliser des espaces, des accents ou des caract√®res sp√©ciaux pour vos noms

.pull-left[
**Non:**
- final.csv (*pas-informatif !*)
- safnnejs.csv (*C'est n'importe quoi!*)
- 1-4.csv  (*Eviter d'utiliser des chiffres!*)
- Ne.pas.separer.par.des.points.csv (*Peut causer des erreurs de lecture de fichier !*)
]

.pull-right[
**Oui:**
- rawDatasetAgo2017.csv
- co2_concentrations_QB.csv
- 01_figIntro.R
]


---
# Bien nommer les variables

* Utilisez des noms de variables courts et informatifs (i.e. "Temps_1" au lieu de "Temps de la premi√®re mesure")
* Les valeurs des colonnes doivent correspondre √† l'usage pr√©vu



.pull-left[
**Bien !**
  - Measurements
  - SpeciesNames
  - Site
]

.pull-right[
**Pas bien !**
 - a
 - 3
 - supernomunpeutroplong]

&lt;br&gt;
&lt;br&gt;
Regardez le guide [tidyverse](https://style.tidyverse.org/) pour plus de conseils.

---
# Conseils pour pr√©parer les donn√©es

.pull-left[
* Pas de texte dans les colonnes de mode num√©rique
* Pas d'espace
* Identifiez les valeurs manquantes par NA ("not available")
* Faites attention aux erreurs typographiques!
]

.pull-right[
* √âvitez les valeurs num√©riques pour les variables n'ayant pas un sens num√©rique (i.e. individu, r√©plicat, traitement)
* Utilisez un format uniforme pour les dates, les chiffres, etc.
* N'ajoutez pas de notes, d'ent√™tes suppl√©mentaires, ou de cellules fusionn√©es!
* Une variable par colonne! ]

&lt;br&gt;
&lt;br&gt;
Lire le paper de [Broman &amp; Woo (2017)](https://doi.org/10.1080/00031305.2017.1375989) 
pour plus de conseils sur l'organisation des donn√©es. 

---
# Exemples de mauvaises habitudes:

&lt;br&gt;

.pull-left[
![:scale 115%](images/Excel_csv_good_bad/excel_values.png)
]

.pull-right[
![:scale 115%](images/Excel_csv_good_bad/excel_notes.png)
]

---
# Exemples de tr√®s mauvaises pr√©sentations


.center[
![:scale 90%](images/HorribleData.png)]


---
# Pr√©parer ses donn√©es dans R

Il est possible de faire toute la pr√©paration des donn√©es dans R. Les avantages sont :

* On √©conomise du temps pour les grosses bases de donn√©es
* On pr√©serve les donn√©es d'origine
* On peut basculer entre les modes "long" et "large" tr√®s facilement (plus de d√©tails plus tard)
* Pour des informations compl√©mentaires, consultez la page suivante :  https://www.zoology.ubc.ca/~schluter/R/data/

---
class: inverse, center, middle

# √âcrire un script dans R

---
# Les scripts R

* Un script R c'est
  * un fichier texte contenant toutes les commandes n√©cessaires pour r√©aliser un projet.
  * Une fois √©crit et enregistr√©, votre script R vous permettra d'apporter des changements et de refaire des analyses avec un minimum d'effort.
  * S√©lectionnez simplement une commande et appuyez sur "Run" ou sur 'command-enter' (Mac) ou 'ctrl-enter' (PC).


---
# Cr√©er un script dans R

.center[
![:scale 80%](images/1_Create_an_R_script.png)
]

---
# √âcrire un script dans R


.center[
![:scale 90%](images/2_Create_an_R_script2.Mod_arrow.png)
]


---
# Commandes &amp; Commentaires

Utilisez le symbole `#` pour ins√©rer des commentaires au sein d'un script. Ceci indique √† R d'ignorer tout ce qui se trouve √† la suite du symbole `#` lors de l'ex√©cution de commandes.


```r
# Ceci est un commentaire pas une commande R!
```

---
# Commandes &amp; Commentaires

**Annoter son script est un bon moyen de** :

  * se rappeler ce que vous avez fait
  * dire aux collaborateurs ce que vous avez fait
  * favoriser une science reproductible

.comment[Soyez aussi d√©taill√© que possible !]


---
# Ent√™tes de section

Il est recommand√© de commencer vos scripts avec un ent√™te pour indiquer des infos importantes: nom du projet, auteur, date, version de R, etc.

.center[
![:scale 75%](images/3_Header.Mod_arrow.png)
]


---
# Ent√™tes de section

Sur R studio, Vous pouvez utiliser quatre symboles `#` de suite pour cr√©er un ent√™te de section.

Par exemple :

```r
#### Chargement du fichier de donn√©es ####
```

Cela vous permet de passer rapidement d'une section √† l'autre et de masquer des sections.

.center[
![:scale 60%](images/4_Section_headings_Mod_arrow 2.png)
]


---
# Nettoyage

C'est une bonne habitude de maintenir son espace de travail propre en effa√ßant la m√©moire de R √† l'aide de `rm(list=ls())`.


```r
rm(list = ls()) # Efface ce qui se trouve dans l'espace de travail
?rm
?ls
```

Cette commande permet d'√©viter d'utiliser un vieux jeu de donn√©es qui serait rest√© dans l'espace de travail.

---
# Nettoyage

On peut tester cette commande en ajoutant des objets dans l'espace de travail pour mieux comprendre comment `rm(list=ls())` fonctionne.



```r
A&lt;-"Test" # On cr√©e un objet "A".
A &lt;- "Test" # Utilisez des espaces - plus facile √† lire
A = "Test"

# Note: il est recommand√© d'utiliser "&lt;-" pour l'assigment au lieu de "="

# Visualiser des objets en m√©moire
ls()
# [1] "A"

A
# [1] "Test"

# Nettoyer la m√©moire
rm(list=ls())

A
# Error in eval(expr, envir, enclos): object 'A' not found
```

---
# Petit rappel important

* R est pr√™t √† ex√©cuter une commande lorsque vous voyez le chevron `&gt;` affich√© dans la console. Si le chevron n'appara√Æt pas, c'est qu'une commande est incompl√®te. Appuyez sur 'ESC' pour sortir de cette commande.
* R est sensible √† la casse, i.e. `A` est diff√©rent de `a`.


```r
a &lt;- 10
A &lt;- 5
a
# [1] 10
A
# [1] 5
rm(list=ls())  # On nettoie l'espace de travail √† nouveau !
```

---
class: inverse, center, middle

# Charger, explorer et enregistrer des donn√©es

---
# T√©l√©charger les donn√©es

Vous pouvez t√©l√©charger les donn√©es et le script depuis :

.center[http://qcbs.ca/wiki/r/workshop2]

Enregistrez les fichiers dans le dossier o√π vous avez cr√©e votre projet R.

--

&lt;br&gt;

.alert[NOTE] Il existe des donn√©es d√©j√† disponibles sur R


```r
# Liste complete de tous les donn√©es disponibles sur base R
library(help = "datasets")
```

---
# R√©pertoire de travail

Si vous n'utilisez pas un **projet RStudio**, vous devez indiquer √† R le r√©pertoire o√π se trouvent les fichiers de donn√©es afin de les charger.

Pour voir quel r√©pertoire R utilise :


```r
getwd()
```

Si ce n'est pas le r√©pertoire avec lequel vous souhaitez travailler, vous pouvez d√©finir le v√¥tre √† l'aide de:


```r
setwd("C:/Users/mon_repertoire")
```

.comment[Il est recommand√© de cr√©er un projet RStudio et ne pas utiliser `setwd()` pour faciliter la reproducibilit√©]

---
# Afficher le contenu du r√©pertoire de travail

La fonction `dir()` affiche le contenu du r√©pertoire de travail.


```r
dir()
# [1] "data"                   "images"                 "qcbsR-fonts.css"       
# [4] "qcbsR-header.html"      "qcbsR-macros.js"        "qcbsR.css"             
# [7] "workshop02-pres-fr.Rmd"
```

Vous pouvez v√©rifier:

* Si le fichier que vous voulez ouvrir se trouve dans le r√©pertoire de travail
* L'orthographe du nom du fichier (e.g. 'monfichier.csv' au lieu de 'MonFichier.csv')


---
# Importer un jeu de donn√©es

Utilisez la fonction `read.csv()` pour importer des donn√©es provenant d'un fichier .csv dans R.


```r
CO2 &lt;- read.csv("data/co2_good.csv", header=TRUE)
```

- Cette commande va cr√©er un objet nomm√© `CO2`
- Le nom du fichier est √©crit entre guillemets (`'file'` ou `"file"`)
- Si vous voulez charger un fichier d'un autre r√©pertoire, vous devrez √©crire l'extension compl√®te: `read.csv("C:/Users/Mario/Downloads/co2_good.csv")`
- `header = TRUE` permet de sp√©cifier que la premi√®re ligne du fichier contient le nom des colonnes

---
# Importer un jeu de donn√©es

Rappelez-vous que vous pouvez obtenir de l'aide pour une fonction avec `?`


```r
?read.csv
```

.alert[NOTE] Si vous utilisez un syst√®me d'exploitation en fran√ßais ou un √©diteur CSV, il est possible que vous deviez utiliser la fonction `read.csv2()` pour importer correctement un fichier.


```r
?read.csv2
```

---
#  Importer un jeu de donn√©es

.center[
![](images/5_Importing_data_Mod_arrow.png)
]

Prenez note que RStudio montre maintenant le jeu de donn√©es CO2 dans votre **espace de travail**. 

L'espace de travail inclut tous les objets cr√©√©s pendant la session R.


---
# Visualiser les donn√©es

R code  					| action
----------------- | -------------
`CO2`					  		| Affiche le tableau de donn√©es complet dans la console
`head(CO2)`		  		| Affiche les premi√®res lignes du tableau de donn√©es
`tail(CO2)`         | Affiche les derni√®res lignes du tableau de donn√©es
`names(CO2)`				| Affiche le nom des colonnes du tableau de donn√©es
`attributes(CO2)`		| Affiche les attributs du tableau de donn√©es
`dim(CO2)`          | Affiche la dimension du tableau de donn√©es
`ncol(CO2)`         | Affiche le nombre de colonnes du tableau de donn√©es
`nrow(CO2)`					| Affiche le nombre de lignes du tableau de donn√©es
`summary(CO2)`			| Calcule quelques statistiques de base sur les variables

.small[.alert[NOTE] Ces fonctions sont aussi utilis√©s pour d'autres objets tels que `vector`, `matrix`, `list`, `array`, etc.]

---
# Visualiser les donn√©es


```r
str(CO2)
# 'data.frame':	84 obs. of  5 variables:
#  $ Plant    : chr  "Qn1" "Qn1" "Qn1" "Qn1" ...
#  $ Type     : chr  "Quebec" "Quebec" "Quebec" "Quebec" ...
#  $ Treatment: chr  "nonchilled" "nonchilled" "nonchilled" "nonchilled" ...
#  $ conc     : int  95 175 250 350 500 675 1000 95 175 250 ...
#  $ uptake   : num  16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...
```
La fonction `str()` est tr√®s utile pour identifier le type/mode de chaque colonne.

.small[Note : Le jeu de donn√©es `CO2` contient des mesures r√©p√©t√©es d'absorption de CO2 prises sur 6 plantes du Qu√©bec et 9 plantes du Mississippi √† diff√©rentes concentrations de CO2 ambiant. La moiti√© des plantes de chaque r√©gion a subi un traitement de refroidissement la veille du d√©but de l'exp√©rience.]


---
# Visualiser les donn√©es

Probl√®mes fr√©quents lors de l'importation des donn√©es :

* Les facteurs apparaissent comme des cha√Ænes de caract√®res (et vice versa)
* Les facteurs ont trop de niveaux √† cause d'une erreur de frappe
* Les donn√©es num√©riques sont stock√©es sous forme de cha√Ænes de caract√®res √†¬†cause d'une erreur de frappe



---
# Exercice

Chargez les donn√©es de nouveau en utilisant le script suivant :



```r
CO2 &lt;- read.csv("data/co2_good.csv", header = FALSE)
```

V√©rifiez la structure des donn√©es avec la fonction `str()`.

Quel est le probl√®me ?

--

.comment[N'oubliez pas de recharger les donn√©es avec l'argument `header=TRUE` avant de continuer.]

---
# Rappel de l'atelier 1 : Acc√©der aux donn√©es

Plusieurs fa√ßons d'extraire les donn√©es avec les crochets. Consid√©rons un jeu de donn√©es nomm√© `mydata`.

.center[
![:scale 45%](images/Table_Reminder_from_Workshop_1_Accessing_data.png)
]


```r
mydata[1,] # Extrait la 1√®re ligne
mydata[2,3] # Extrait la 2√®me ligne / 3√®me colonne
mydata[,1] # Extrait la 1√®re colonne
mydata[,1][2] # [...] peut √™tre utilis√© r√©cursivement
mydata$Variable1 # Extrait la colonne "Variable1"
```

---
# Renommer les variables

On peut renommer les variables (colonnes) dans R.


```r
# Cr√©er une copie du jeu de donn√©es qu'on pourra modifier
CO2copy &lt;- CO2

# names() donne les noms des variables pr√©sentes dans le jeu de donn√©es
names(CO2copy)
# [1] "Plant"     "Type"      "Treatment" "conc"      "uptake"

# Changer des noms anglais pour des noms fran√ßais
names(CO2copy) &lt;- c("Plante", "Categorie", "Traitement", "conc", "absorption")
names(CO2copy)
# [1] "Plante"     "Categorie"  "Traitement" "conc"       "absorption"
```

---
# Cr√©er des nouvelles variables

On peut facilement cr√©er et produire des nouvelles variables. Par exemple, la fonction `paste()` permet la concat√©nation de cha√Ænes de caract√®res et de variables. Consultez `?paste` et `?paste0`.

Cr√©er un ID unique pour les √©chantillons avec la fonction `paste0()`


```r
# N'oubliez pas d'utiliser "" pour les cha√Ænes de caract√®res
CO2copy$uniqueID &lt;- paste0(CO2copy$Plante,
                           "_", CO2copy$Categorie,
                           "_", CO2copy$Traitement)

# Observer les r√©sultats
head(CO2copy$uniqueID)
# [1] "Qn1_Quebec_nonchilled" "Qn1_Quebec_nonchilled" "Qn1_Quebec_nonchilled"
# [4] "Qn1_Quebec_nonchilled" "Qn1_Quebec_nonchilled" "Qn1_Quebec_nonchilled"
```

---
# Cr√©er des nouvelles variables

On peut aussi cr√©er des nouvelles variables √† partir de chiffres et d'op√©rations math√©matiques!


```r
# Standardizer la variable "absorption" en valeurs relatives
CO2copy$absorptionRel &lt;- CO2copy$absorption/max(CO2copy$absorption)

# Observer les r√©sultats
head(CO2copy$absorptionRel)
# [1] 0.3516484 0.6681319 0.7648352 0.8175824 0.7758242 0.8615385
```

---
# Sous-ensemble d'un data frame

Il existe plusieurs fa√ßons d'en faire :


```r
# On continue √† travailler avec notre jeux de donn√©es CO2copy

# Extraire un sous-ensemble par un nom de variable
CO2copy[, c("Plante", "absorptionRel")]

# Extraire un sous-ensemble de rang√©es
CO2copy[1:50, ]
```

---
# Sous-ensemble d'un data frame


```r
# Extraire les observations du traitement "nonchilled"
CO2copy[CO2copy$Traitement == "nonchilled", ]

# Extraire selon une condition num√©rique
CO2copy[CO2copy$absorption &gt;= 20, ]

# Extraire selon plusieurs conditions num√©riques
CO2copy[CO2copy$Traitement  == "nonchilled" &amp; CO2copy$absorption &gt;= 20, ]

# Nous avons fini de modifier le data frame CO2copy, effa√ßons-le
rm(CO2copy)
```

Consultez [ici](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Logic.html) pour voir les op√©rateurs logiques pouvant √™tre utilis√©s pour extraire des sous-ensembles de donn√©es dans R.

---
# Explorer les donn√©es

Un bon moyen de commencer votre exploration des donn√©es consiste √† regarder des statistiques de base sur votre jeu de donn√©es.

Utilisez la fonction `summary()`.


```r
summary(CO2)
```

C'est √©galement utile pour rep√©rer certaines erreurs que vous auriez peut-√™tre manqu√©es!

---
# Explorer les donn√©es

Vous pouvez √©galement utiliser d'autres fonctions pour calculer des statistiques de base pour des parties sp√©cifiques de votre trame de donn√©es.

Essayons les fonctions `mean()`, `sd()` et `hist()` :


```r
# Calculer la moyenne et l'√©cart type de la concentration,
# et les assigner √† de nouvelles variables
meanConc &lt;- mean(CO2$conc)
sdConc &lt;- sd(CO2$conc)
```


```r
# print() imprime une valeur donn√©e dans la console R
print(paste("the mean of concentration is:", meanConc))
# [1] "the mean of concentration is: 435"

print(paste("the standard deviation of concentration is:", sdConc))
# [1] "the standard deviation of concentration is: 295.924119222056"
```

---
# Explorer les donn√©es


```r
# Cr√©ons un histogramme pour explorer la distribution de "uptake"
hist(CO2$uptake)
```

&lt;img src="workshop02-pres-fr_files/figure-html/unnamed-chunk-24-1.png" width="432" style="display: block; margin: auto;" /&gt;

---
# Explorer les donn√©es


```r
# Cr√©ons un histogramme pour explorer la distribution de "uptake"
hist(CO2$uptake, breaks = 40) # breaks permet de changer le nombre de classes
```

&lt;img src="workshop02-pres-fr_files/figure-html/unnamed-chunk-25-1.png" width="432" style="display: block; margin: auto;" /&gt;

---
# Enregistrer son espace de travail


```r
# Sauver l'espace de travail avec tous les objets
save.image(file="data/co2_project_Data.RData")

# Nettoyer l'espace de travail
rm(list = ls())

# Charger tout ce qui se trouvait dans l'espace de travail
load("data/co2_project_Data.RData")
head(CO2) # cela fonctionne! :)
```


```
#   Plant   Type  Treatment conc uptake
# 1   Qn1 Quebec nonchilled   95   16.0
# 2   Qn1 Quebec nonchilled  175   30.4
# 3   Qn1 Quebec nonchilled  250   34.8
# 4   Qn1 Quebec nonchilled  350   37.2
# 5   Qn1 Quebec nonchilled  500   35.3
# 6   Qn1 Quebec nonchilled  675   39.2
```

---
# Exporter des donn√©es

Pour enregistrer dans le r√©pertoire de travail des donn√©es que vous avez cr√©√©es ou modifi√©es dans R, utilisez la fonction `write.csv()`.


```r
write.csv(CO2, file = "data/co2_new.csv")
```

`CO2` ![:faic](arrow-right) Nom de l'objet dans R

`"co2_new.csv"` ![:faic](arrow-right) Nom du nouveau fichier √† enregistrer


---
# D√©fi  ![:cube]()

#### Utilisez vos donn√©es

- Essayez de charger, explorer, et enregistrer vos propres donn√©es dans R

.comment[

* Si ce n'est pas le cas, essayez de corriger vos donn√©es dans Excel.

* Enregistrez vos donn√©es corrig√©es et r√©-essayez de les ouvrir dans R.

* Si vous n'avez pas de donn√©es, travaillez avec vos voisins

* N'oubliez pas de nettoyer votre espace de travail

]

---
class: inverse, center, middle

# R√©parer un jeu de donn√©es


---
# R√©parer un jeu de donn√©es "endommag√©"

Charger vos donn√©es peut √™tre plus difficile que vous ne le pensez!

Les jeux de donn√©es peuvent √™tre d√©sordonn√©s et incompatibles entre certains syst√®mes (Mac, Windows) ou entre ordinateurs.

Pratiquons-nous √† r√©parer certains probl√®mes communs.

---
# D√©fi ![:cube]()

Lire le ficher `co2_broken.csv`


```r
CO2 &lt;- read.csv("data/co2_broken.csv")
head(CO2) # C'est le bordel!
#               NOTE..It.rain.a.lot.in.Quebec.during.sampling due.to.excessive  X
# 1 falling on my notebook numerous values can't be read rain               NA NA
# 2                      Plant\tType\tTreatment\tconc\tuptake               NA NA
# 3                           Qn1\tQuebec\tnonchilled\t95\t16               NA NA
# 4                        Qn1\tQuebec\tnonchilled\t175\t30.4               NA NA
# 5           Qn1\tQuebec\tnonchilled\t250\tcannot_read_notes               NA NA
# 6                        Qn1\tQuebec\tnonchilled\t350\t37.2               NA NA
#   X.1 X.2 X.3
# 1  NA  NA  NA
# 2  NA  NA  NA
# 3  NA  NA  NA
# 4  NA  NA  NA
# 5  NA  NA  NA
# 6  NA  NA  NA
```

---
# D√©fi ![:cube]()

Voici quelques fonctions qui peuvent vous aider :

* `read.csv()` - examinez les options permettant de charger un fichier .csv
* `head()` - montre les premi√®res lignes
* `str()` - structure de donn√©es
* `class()` - classe de l'objet
* `unique()` - observations uniques
* `levels()` - niveaux d'un facteur
* `which()` - pose une question sur votre bloc de donn√©es
* `droplevels()` - supprime les niveaux ind√©sirables apr√®s avoir d√©duit les facteurs

.alert[Indice] Il y a quatre probl√®mes avec ce jeu de donn√©es!


---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 1]

Les donn√©es sont contenues dans une seule colonne


```r
head(CO2)
#               NOTE..It.rain.a.lot.in.Quebec.during.sampling due.to.excessive  X
# 1 falling on my notebook numerous values can't be read rain               NA NA
# 2                      Plant\tType\tTreatment\tconc\tuptake               NA NA
# 3                           Qn1\tQuebec\tnonchilled\t95\t16               NA NA
# 4                        Qn1\tQuebec\tnonchilled\t175\t30.4               NA NA
# 5           Qn1\tQuebec\tnonchilled\t250\tcannot_read_notes               NA NA
# 6                        Qn1\tQuebec\tnonchilled\t350\t37.2               NA NA
#   X.1 X.2 X.3
# 1  NA  NA  NA
# 2  NA  NA  NA
# 3  NA  NA  NA
# 4  NA  NA  NA
# 5  NA  NA  NA
# 6  NA  NA  NA
```

---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 1] - Solution

* Importez les donn√©es de nouveau, en sp√©cifiant comment chaque valeur est s√©par√©e.
* L'argument `sep` indique √† R quel type de caract√®re s√©pare les valeurs sur chaque ligne.
* Ici, une tabulation s√©pare les valeurs au lieu d'une virgule.


```r
CO2 &lt;- read.csv("data/co2_broken.csv", sep = "")
```

---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 2]

Les donn√©es ne commencent pas avant la 3√®me ligne. Les ent√™tes de colonnes sont remplac√©s par des notes.


```r
head(CO2)
#     NOTE.     It       rain        a               lot    in. Quebec during
# 1 falling     on         my notebook          numerous values  can't     be
# 2   Plant   Type  Treatment     conc            uptake                     
# 3     Qn1 Quebec nonchilled       95                16                     
# 4     Qn1 Quebec nonchilled      175              30.4                     
# 5     Qn1 Quebec nonchilled      250 cannot_read_notes                     
# 6     Qn1 Quebec nonchilled      350              37.2                     
#   sampling.      due to excessive X....
# 1      read rain,,,, NA        NA    NA
# 2                    NA        NA    NA
# 3                    NA        NA    NA
# 4                    NA        NA    NA
# 5                    NA        NA    NA
# 6                    NA        NA    NA
```

---
# Jeu de donn√©es "endommag√©"
.alert[ERREUR 2] - Solution

Pour r√©gler ce probl√®me, vous devez indiquer √† R de sauter les deux premi√®res lignes avec l'argument "skip".


```r
CO2 &lt;- read.csv("data/co2_broken.csv", sep = "", skip = 2)
head(CO2)
#   Plant   Type  Treatment              conc            uptake
# 1   Qn1 Quebec nonchilled                95                16
# 2   Qn1 Quebec nonchilled               175              30.4
# 3   Qn1 Quebec nonchilled               250 cannot_read_notes
# 4   Qn1 Quebec nonchilled               350              37.2
# 5   Qn1 Quebec nonchilled               500              35.3
# 6   Qn1 Quebec nonchilled cannot_read_notes              39.2
```

---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 3] Les variables `conc` et `uptake` sont consid√©r√©es comme des facteurs au lieu de nombres, car il y a du texte dans ces colonnes.


```r
str(CO2)
# 'data.frame':	84 obs. of  5 variables:
#  $ Plant    : chr  "Qn1" "Qn1" "Qn1" "Qn1" ...
#  $ Type     : chr  "Quebec" "Quebec" "Quebec" "Quebec" ...
#  $ Treatment: chr  "nonchilled" "nonchilled" "nonchilled" "nonchilled" ...
#  $ conc     : chr  "95" "175" "250" "350" ...
#  $ uptake   : chr  "16" "30.4" "cannot_read_notes" "37.2" ...
```


```r
unique(CO2$conc)
# [1] "95"                "175"               "250"              
# [4] "350"               "500"               "cannot_read_notes"
# [7] "1000"              "675"
```

---
# `?read.csv`

![:scale 80%](images/read_table_help1.png)

![:scale 80%](images/read_table_help2.png)

---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 3] - Solution

Indiquez √† R que tous les √©l√©ments NA, "na" et "cannot_read_notes" doivent √™tre consid√©r√©s comme des NA. Ensuite, comme toutes les autres valeurs de ces colonnes sont des nombres, `conc` et` uptake` seront charg√©s sous forme num√©rique / entier.


```r
CO2 &lt;- read.csv("data/co2_broken.csv", sep = "", skip = 2,
                na.strings = c("NA", "na", "cannot_read_notes"))
str(CO2)
# 'data.frame':	84 obs. of  5 variables:
#  $ Plant    : chr  "Qn1" "Qn1" "Qn1" "Qn1" ...
#  $ Type     : chr  "Quebec" "Quebec" "Quebec" "Quebec" ...
#  $ Treatment: chr  "nonchilled" "nonchilled" "nonchilled" "nonchilled" ...
#  $ conc     : int  95 175 250 350 500 NA 1000 95 175 250 ...
#  $ uptake   : num  16 30.4 NA 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...
```


---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 4]

En r√©alit√©, il y a seulement 2 traitements (chilled &amp; non chilled), mais des erreurs d'orthographe cr√©ent 2 autres niveaux de traitement.


```r
str(CO2)
```


```r
levels(CO2$Treatment)
# NULL
unique(CO2$Treatment)
# [1] "nonchilled" "nnchilled"  "chilled"    "chiled"
```

---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 4] - Solution



```r
# Identifier toutes les lignes contenant "nnchilled" et remplacer par "nonchilled"
CO2$Treatment[which(CO2$Treatment=="nnchilled")] &lt;- "nonchilled"

# Faisons la m√™me chose pour "chiled" :
CO2$Treatment[which(CO2$Treatment=="chiled")] &lt;- "chilled"
```

---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 4] - Solution

Apr√®s avoir r√©par√© les facteurs, il faut enlever les niveaux de facteur non utilis√©s

Sinon :


```r
boxplot(uptake ~ Treatment, data = CO2)
```

&lt;img src="workshop02-pres-fr_files/figure-html/unnamed-chunk-40-1.png" width="360" style="display: block; margin: auto;" /&gt;

---
# Jeu de donn√©es "endommag√©"

.alert[ERREUR 4] - Solution


```r
CO2 &lt;- droplevels(CO2)
str(CO2)
# 'data.frame':	84 obs. of  5 variables:
#  $ Plant    : chr  "Qn1" "Qn1" "Qn1" "Qn1" ...
#  $ Type     : chr  "Quebec" "Quebec" "Quebec" "Quebec" ...
#  $ Treatment: chr  "nonchilled" "nonchilled" "nonchilled" "nonchilled" ...
#  $ conc     : int  95 175 250 350 500 NA 1000 95 175 250 ...
#  $ uptake   : num  16 30.4 NA 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...
```

.pull-left[

```r
boxplot(uptake ~ Treatment, data = CO2)
```
]
.pull-right[
&lt;img src="workshop02-pres-fr_files/figure-html/unnamed-chunk-43-1.png" width="360" style="display: block; margin: auto;" /&gt;
]

---
class: inverse, center, middle

# Bienvenue dans le monde de tidyverse !

---
# Qu'est ce que Tidyverse?

[`Tidyverse`](https://www.tidyverse.org/) est un ensemble de packages con√ßus pour la manipulation de donn√©es en science.

`Tidyverse` contient des outils plus efficaces et conviviales tr√®s utiles pour toutes sortes d‚Äôanalyses.  

Tous les packages inclus dans `tidyverse` sont automatiquement install√©s lors de l'installation de `tidyverse` : `install.packages("tidyverse")`
&lt;br&gt;
&lt;br&gt;
Par exemple : 
* [`tidyr`](https://tidyr.tidyverse.org/): r√©organiser les tables de donn√©es
* [`dplyr`](https://dplyr.tidyverse.org/): manipuler les donn√©es
* [`maggritr`](https://magrittr.tidyverse.org/): lier plusieurs op√©rations
* [`ggplot2`](https://ggplot2.tidyverse.org/): faire des graphiques
* [`readr`](https://readr.tidyverse.org/): lire les donn√©es (plus rapide !)
* [`lubridate`](https://lubridate.tidyverse.org/): manipuler des donn√©es de dates et de temps
* [et plus !](https://www.tidyverse.org/packages/)

---
class: inverse, center, middle

# Manipulation de donn√©es avec

## tidyr, dplyr, magrittr

---
# `tidyr` pour r√©organiser ses donn√©es


```r
library(tidyr)
```

.center[
![:scale 40%](images/tidyr_logo.png)
]

---
# Format de donn√©es

.pull-left[
**Format large (wide)**

.small[Un data frame en format large contient une colonne pour chaque variable ou facteur]


```
#   Species DHP Haut
# 1   Chene  12   56
# 2    Orme  20   85
# 3   Frene  13   55
```
]

.pull-right[
**Format long**

.small[Un data frame en format long contient une colonne par variable, o√π chaque ligne est une observation]


```
#   Species dimension cm
# 1   Chene       DHP 12
# 2    Orme       DHP 20
# 3   Frene       DHP 13
# 4   Chene      Haut 56
# 5    Orme      Haut 85
# 6   Frene      Haut 55
```
]

------------

`ggplot2` peut utiliser le format large pour des visualisations simples, mais des visualisations plus complexes requi√®rent le format long.

`dplyr`, `lm()`, `glm()`, `gam()` n√©cessitent le format long.

---
# Manipuler vos donn√©es

Le paquet `tidyr` permet de manipuler la structure d'un data frame en pr√©servant les informations d'origine

`pivot_longer()` ![:faic](arrow-right) "rassembler" les donn√©es (large -&gt; long)

`pivot_wider()` ![:faic](arrow-right) "disperser" les donn√©es (long -&gt; large)


.center[
![scale:90%](images/gather-spread.png)]

---
# Installation du paquet `tidyr`


```r
install.packages("tidyr")
library(tidyr)
```

---
# Rassembler les colonnes en lignes

`pivot_longer(data, cols, names_to, values_to, ...)`

&lt;span style="font-size: 21px;"&gt;
  - `data` le jeu de donn√©es (e.g. 'large')
  - `cols` les colonnes qu'on veut empiler dans le jeu de donn√©es (e.g. `DHP`, `Haut`)
  - `names_to` le nom de la nouvelle colonne sp√©cifiant la variable mesur√©e (e.g. `dimension`)
  - `values_to` le nom de la nouvelle colonne sp√©cifiant la mesure associ√©e (e.g. `cm`)
&lt;/span&gt;

---
# Rassembler avec `pivot_longer()`


```r
large &lt;- data.frame(Species = c("Chene", "Orme", "Frene"),
                   DHP      = c(12, 20, 13),
                   Haut     = c(56, 85, 55))
large
#   Species DHP Haut
# 1   Chene  12   56
# 2    Orme  20   85
# 3   Frene  13   55
```


```r
long &lt;- pivot_longer(data      = large, 
                     cols      = c("DHP", "Haut"),
                     names_to  = "dimension", 
                     values_to = "cm")
long
# [90m# A tibble: 6 x 3[39m
#   Species dimension    cm
#   [3m[90m&lt;chr&gt;[39m[23m   [3m[90m&lt;chr&gt;[39m[23m     [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m Chene   DHP          12
# [90m2[39m Chene   Haut         56
# [90m3[39m Orme    DHP          20
# [90m4[39m Orme    Haut         85
# [90m5[39m Frene   DHP          13
# [90m6[39m Frene   Haut         55
```

---
# Disperser avec les lignes en colonnes

`pivot_wider(data, names_from, values_from, ...)`

&lt;span style="font-size: 21px;"&gt;
  - `data` le jeu de donn√©es (e.g. `long`)
  - `names_from` nom de la colonne contenant les noms des variables (e.g. `dimension`)
  - `values_from` nom de la colonne contenant les mesures associ√©es aux variables (e.g. `cm`)
&lt;/span&gt;

---
# Disperser avec `pivot_wider()`


```r
long
# [90m# A tibble: 6 x 3[39m
#   Species dimension    cm
#   [3m[90m&lt;chr&gt;[39m[23m   [3m[90m&lt;chr&gt;[39m[23m     [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m Chene   DHP          12
# [90m2[39m Chene   Haut         56
# [90m3[39m Orme    DHP          20
# [90m4[39m Orme    Haut         85
# [90m5[39m Frene   DHP          13
# [90m6[39m Frene   Haut         55
```


```r
large2 &lt;- pivot_wider(data        = long, 
                      names_from  = "dimension", 
                      values_from = "cm")
large2
# [90m# A tibble: 3 x 3[39m
#   Species   DHP  Haut
#   [3m[90m&lt;chr&gt;[39m[23m   [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m Chene      12    56
# [90m2[39m Orme       20    85
# [90m3[39m Frene      13    55
```

---
#  La structure `tibble` pour des tables de donn√©es

`Tibble` est un format alternatif et plus pratique que celui d'un data frame. L'utilisation d'un tribble favorise de bonnes habitudes de programmation. Par exemple, il ne change pas une variable de chaine de caract√®re en facteur.  


```r
tibble(x = 1:3, y = c("a","b","c"))
# [90m# A tibble: 3 x 2[39m
#       x y    
#   [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m
# [90m1[39m     1 a    
# [90m2[39m     2 b    
# [90m3[39m     3 c
```

---
#  La structure `tibble` pour des tables de donn√©es

En plus, `tibble` simplifie l'utilisation de lists imbriqu√©s dans la table de donn√©es.

Exemple: 

```r
tibble(x = 1:3, y = list(1:5, 1:10, 1:20))
# [90m# A tibble: 3 x 2[39m
#       x y         
#   [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;list&gt;[39m[23m    
# [90m1[39m     1 [90m&lt;int [5]&gt;[39m 
# [90m2[39m     2 [90m&lt;int [10]&gt;[39m
# [90m3[39m     3 [90m&lt;int [20]&gt;[39m
```

Toutes les fonctions appliqu√©es sur un data frame peuvent aussi √™tre utilis√©es sur un tibble 

---
# `separate()` des colonnes


.center[
![](images/separate.png)
]


`separate(data, col, into, sep)`

  - `data` ![:faic](arrow-right) Un data frame (e.g. `long`)
  - `col` ![:faic](arrow-right) Nom de la colonne que nous voulons s√©parer
  - `into` ![:faic](arrow-right) Nom des nouvelles colonnes cr√©es par la s√©paration
  - `sep` ![:faic](arrow-right) Caract√®re qui indique o√π s√©parer le contenu

---
# Utiliser `separate()`

Cr√©ons un jeu de donn√©es fictif sur les poissons et le zooplancton :


```r
set.seed(8)
degat &lt;- data.frame(id = 1:4,
                    trt = sample(rep(c('control', 'culture'), each = 2)),
                    zooplancton.T1 = runif(4),
                    poisson.T1 = runif(4),
                    zooplancton.T2 = runif(4),
                    poisson.T2 = runif(4))
degat
#   id     trt zooplancton.T1 poisson.T1 zooplancton.T2 poisson.T2
# 1  1 culture      0.7189275 0.64449114    0.544962116  0.2644589
# 2  2 culture      0.2908734 0.45704489    0.138224346  0.2765322
# 3  3 control      0.9322698 0.08930101    0.927812252  0.5211070
# 4  4 control      0.7691470 0.43239137    0.001301721  0.2236889
```

---
# Utiliser `separate()`

On peut commencer par convertir ce jeu de donn√©es vers le format long.


```r
degat.long &lt;- pivot_longer(degat,
                           names_to = "taxa",
                           cols     = c("zooplancton.T1", 
                                        "poisson.T1",
                                        "zooplancton.T2",
                                        "poisson.T2"))
head(degat.long)
# [90m# A tibble: 6 x 4[39m
#      id trt     taxa           value
#   [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m   [3m[90m&lt;chr&gt;[39m[23m          [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m     1 culture zooplancton.T1 0.719
# [90m2[39m     1 culture poisson.T1     0.644
# [90m3[39m     1 culture zooplancton.T2 0.545
# [90m4[39m     1 culture poisson.T2     0.264
# [90m5[39m     2 culture zooplancton.T1 0.291
# [90m6[39m     2 culture poisson.T1     0.457
```

---
# Utiliser `separate()`

Ensuite, on veut s√©parer les 2 temps d'√©chantillonnage (T1 et T2) dans la colonne "taxa" en utilisant le point comme caract√®re de s√©paration


```r
degat.long.sep &lt;- separate(degat.long, taxa,
                           into = c("especes", "temps"), sep = "\\.")
head(degat.long.sep)
# [90m# A tibble: 6 x 5[39m
#      id trt     especes     temps value
#   [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m   [3m[90m&lt;chr&gt;[39m[23m       [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m     1 culture zooplancton T1    0.719
# [90m2[39m     1 culture poisson     T1    0.644
# [90m3[39m     1 culture zooplancton T2    0.545
# [90m4[39m     1 culture poisson     T2    0.264
# [90m5[39m     2 culture zooplancton T1    0.291
# [90m6[39m     2 culture poisson     T1    0.457
```

.small[
.comment[
L'argument `sep = " \\."` indique √† R de scinder la cha√Æne de caract√®res autour du point (.). Nous ne pouvons pas √©crire directement `sep = "."` car il s‚Äôagit d‚Äôune expression r√©guli√®re qui correspond √† n‚Äôimporte quel caract√®re (un joker).
]]


---
# R√©capitulatif: `tidyr`

`tidyr` est un paquet qui r√©organise la structure de jeux de donn√©es.


Convertir de format large en format long √† l'aide de `pivot_longer()`

Convertir de format long en format large √† l'aide de `pivot_wider()`

S√©parer et regrouper des colonnes √† l'aide de `separate()` et de son inverse `unite()`

[Voici un aide-m√©moire (en anglais) pour faciliter la manipulation de jeux de donn√©es avec tidyr et dplyr](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)


---
# D√©fi #1 ![:cube]()

R√©organisez le jeu de donn√©es `airquality` en format long (en rassemblant toutes les colonnes sauf "Month" et "Day").


```r
?airquality

data(airquality)
```

---
# Solution #1

R√©organisez le jeu de donn√©es `airquality` en format long (en rassemblant toutes les colonnes sauf "Month" et "Day").


```r
air.long &lt;- pivot_longer(airquality,
                         cols     = c("Ozone", "Solar.R", "Wind", "Temp"), 
                         names_to = c("variable"))

head(air.long)
# [90m# A tibble: 6 x 4[39m
#   Month   Day variable value
#   [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m    [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m     5     1 Ozone     41  
# [90m2[39m     5     1 Solar.R  190  
# [90m3[39m     5     1 Wind       7.4
# [90m4[39m     5     1 Temp      67  
# [90m5[39m     5     2 Ozone     36  
# [90m6[39m     5     2 Solar.R  118
```

---
# D√©fi #2 ![:cube]()

Convertissez-le en format large pour retrouver le format original de `airquality`

---
# Solution #2

Convertissez-le en format large pour retrouver le format original de `airquality`


```r
air.wide &lt;- pivot_wider(air.long,
                        values_from = "value",
                        names_from  = "variable")
head(air.wide)
# [90m# A tibble: 6 x 6[39m
#   Month   Day Ozone Solar.R  Wind  Temp
#   [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m   [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m     5     1    41     190   7.4    67
# [90m2[39m     5     2    36     118   8      72
# [90m3[39m     5     3    12     149  12.6    74
# [90m4[39m     5     4    18     313  11.5    62
# [90m5[39m     5     5    [31mNA[39m      [31mNA[39m  14.3    56
# [90m6[39m     5     6    28      [31mNA[39m  14.9    66
```

---
# Manipulation avec `dplyr`

.center[
![:scale 50%](images/dplyr_logo.png)]


---
# Introduction √† `dplyr`

La mission de `dplyr` est de simplifier nos t√¢ches de manipulation.

- Package contenant un ensemble de fonctions (ou *verbes*) pour la manipulation de donn√©es, telles que le filtrage des lignes, la s√©lection de colonnes sp√©cifiques, le r√©organisation des lignes, l'ajout de nouvelles colonnes et la synth√®se des donn√©es;
- Fonctions simples et intuitives;
- Rapide et efficace avec les grands jeux de donn√©es;
- Peut s‚Äôinterfacer avec des bases de donn√©es externes et traduire votre code R en requ√™tes SQL

Certaines fonctions de base dans R ressemblent √† des fonctions dans `dplyr`: `split()`, `subset()`, `apply()`, `sapply()`, `lapply()`, `tapply()` et `aggregate()`

---
# Introduction √† `dplyr`

Commen√ßons par installer et charger le paquet `dplyr`


```r
library(dplyr)
```

---
# Fonctions de bases de `dplyr`

Voici les 4 *verbes* principaux qui permettent d'ex√©cuter les manipulations les plus communes:

  * `select()`: s√©lectionne des colonnes dans un jeu de donn√©es
  * `filter()`: filtre des rang√©es suivant les crit√®res sp√©cifi√©s
  * `arrange()`: trie les donn√©es d'une colonne en ordre croissant ou d√©croissant
  * `mutate()`: cr√©e une nouvelle colonne de donn√©es (ou transforme une colonne existante)


---
# `select()` - S√©lection de colonnes

.center[![:scale 60%](images/select.png)]


`select(data, ...)`

  * `data` : le jeu de donn√©es
  * `...` : noms ou positions de colonnes, ou expressions complexes (s√©par√©s par des virgules pour d√©signer les colonnes que l'on veut s√©lectionner

Examples :


```r
select(donn√©es, colonne1, colonne2) # s√©lectionne colonne1 et colonne2
select(donn√©es, c(2:4,6) # s√©lectionne les colonnes 2 √† 4, plus la 6√®me colonne
select(donn√©es, -colonne1) # s√©lectionne toutes les colonnes sauf la 1√®re
select(donn√©es, start_with(x.)) # s√©lectionne les colonnes ayant un nom qui commence par "x."
```

---
# `select()` - S√©lection de colonnes

.center[![:scale 70%](images/select.helper.png)]


---
# `select()` - S√©lection de colonnes

Par exemple, si on analyse la variation de la variable Ozone avec le temps.


```r
ozone &lt;- select(airquality, Ozone, Month, Day)
head(ozone)
#   Ozone Month Day
# 1    41     5   1
# 2    36     5   2
# 3    12     5   3
# 4    18     5   4
# 5    NA     5   5
# 6    28     5   6
```

---
# `filter()` - s√©lection de lignes

Pour extraire un sous-ensemble de rang√©es selon une condition, on peut utiliser la fonction `filter()` avec la syntaxe suivante:

`filter(dataframe, propostion logique 1, propostion logique 2, ...)`

&lt;br&gt;

.center[![:scale 90%](images/filter.png)]

.center[![:scale 90%](images/logic.helper.png)]



---
# `filter()` - s√©lection de lignes

Par exemple, si on s'int√©resse aux p√©riodes de canicules du mois d'ao√ªt dans le jeu de donn√©es `airquality`


```r
aout &lt;- filter(airquality, Month == 8, Temp &gt;= 90)
# ou filter(airquality, Month == 8 &amp; Temp &gt;= 90)
head(aout)
#   Ozone Solar.R Wind Temp Month Day
# 1    89     229 10.3   90     8   8
# 2   110     207  8.0   90     8   9
# 3    NA     222  8.6   92     8  10
# 4    76     203  9.7   97     8  28
# 5   118     225  2.3   94     8  29
# 6    84     237  6.3   96     8  30
```

---
# Ordonner des lignes avec `arrange()`

R√©ordonne les lignes selon une ou plusieurs colonnes, par d√©faut en ordre croissant

`arrange(donn√©es, variable1, variable2, ...)`

On peut √©galement r√©ordonner les lignes en ordre d√©croissant en utilisant la fonction `desc()` √† l'int√©rieur de la fonction `arrange()`

`arrange(data, variable1, desc(variable2), ...)`

---
# Ordonner des lignes avec `arrange()`

Example :

1) Commen√ßons par cr√©er une version d√©sordonn√©e de `airquality`:


```r
air_degat &lt;- sample_frac(airquality, 1)
head(air_degat)
#   Ozone Solar.R Wind Temp Month Day
# 1    23     115  7.4   76     8  18
# 2    28     273 11.5   82     8  13
# 3     8      19 20.1   61     5   9
# 4   135     269  4.1   84     7   1
# 5    23     299  8.6   65     5   7
# 6    30     322 11.5   68     5  19
```

---
# Ordonner des lignes avec `arrange()`

Example :

2) Maintenant, on r√©arrange le data frame en ordre chronologique, soit en ordre croissant selon `Month` et ensuite selon `Day`


```r
air_chron &lt;- arrange(air_degat, Month, Day)
head(air_chron)
#   Ozone Solar.R Wind Temp Month Day
# 1    41     190  7.4   67     5   1
# 2    36     118  8.0   72     5   2
# 3    12     149 12.6   74     5   3
# 4    18     313 11.5   62     5   4
# 5    NA      NA 14.3   56     5   5
# 6    28      NA 14.9   66     5   6
```

.comment[Essayez `arrange(air_mess, Day, Month)` et voyez la diff√©rence.]


---
# `mutate()` - Cr√©er de nouvelles colonnes

On peut utiliser la fonction `mutate()` pour cr√©er et transformer des variables.

`mutate(data, newVar1 = expression1, newVar2 = expression2, ...)`

.center[ ![](images/mutate.png)
]


---
# `mutate()` - Cr√©er de nouvelles colonnes

Par exemple, on veut transformer la variable temp√©rature `Temp` de degr√©s Fahrenheit vers degr√©s Celsius


```r
airquality_C &lt;- mutate(airquality, 
                       Temp_C = (Temp-32)*(5/9))
head(airquality_C)
#   Ozone Solar.R Wind Temp Month Day   Temp_C
# 1    41     190  7.4   67     5   1 19.44444
# 2    36     118  8.0   72     5   2 22.22222
# 3    12     149 12.6   74     5   3 23.33333
# 4    18     313 11.5   62     5   4 16.66667
# 5    NA      NA 14.3   56     5   5 13.33333
# 6    28      NA 14.9   66     5   6 18.88889
```

---
# `magrittr`

Habituellement, la manipulation de donn√©es n√©cessite plusieurs √©tapes, le package `magrittr` propose l'op√©rateur `%&gt;%` (*pipe operator*) qui nous permet de lier plusieurs op√©rations.

.center[
![:scale 40%](images/magrittr.png)]

---
# `magrittr`

Commen√ßons par installer et charger le paquet :


```r
library(magrittr)
```

---
# `magrittr`

Supposons qu'on veut cr√©er un sous-ensemble de airquality pour le mois de juin, et ensuite convertir la variable de la temp√©rature en degr√©s Celsius. On peut cr√©er ce data frame en combinant 2 *verbes* de dplyr


```r
juin_C &lt;- mutate(filter(airquality, Month == 6),
                 Temp_C = (Temp-32)*(5/9))
```

.comment[Plus on ajoute des op√©rations, plus ce code deviendra illisible. Mais, le faire √©tape par √©tape serait redondant et √©crirait de nombreux objets dans l'espace de travail.]

---
# `magrittr`

 Au lieu d'envelopper toutes les fonctions, on peut √©crire les op√©rations en ordre d'ex√©cutions et les relier √† l'aide du *pipe* %&gt;% :


```r
juin_C &lt;- airquality %&gt;%
            filter(Month == 6) %&gt;%
            mutate(Temp_C = (Temp-32)*(5/9))
```

Avantages :

  * le code est moins redondant
  * le code est facile √† lire et √† √©crire parce que les fonctions sont ex√©cut√©es dans l'ordre

---
# `dplyr::group_by` et `dplyr::summarise`

Les verbes `dplyr` que nous avons appris dans cet atelier deviennent particuli√®rement puissants quand ils sont reli√©s par le "pipe" (%&gt;%).

Les fonctions `dplyr` suivantes nous permettent de s√©parer nos jeu de donn√©es en groupes distincts sur lesquels on peut ex√©cuter des op√©rations individuelles, comme des fonctions d‚Äôagr√©gation et de sommaire:

`group_by()` ![:faic](arrow-right) regrouper le jeu de donn√©es par un facteur pour les op√©rations en aval (comme `summarise()`)

`summarise()` ![:faic](arrow-right) cr√©er un sommaire de variables au sein de groupes distincts dans un jeu de donn√©es en utilisant des fonctions d'aggr√©gation (e.g. `min()`, `max()`, `mean()`)

---
# `dplyr` - S√©parer-Appliquer-Combiner

La fonction `group_by` est la base de la strat√©gie  S√©parer-Appliquer-Combiner

.center[
![](images/split-apply-combine.png)
]

---
# `dplyr` - S√©parer-Appliquer-Combiner

.center[
![:scale 70%](images/summarise.png)
]


---
# `dplyr` - S√©parer-Appliquer-Combiner

Utilisons ces deux fonctions pour g√©n√©rer un sommaire du jeu de donn√©es `airquality` qui montre la temp√©rature moyenne et l'√©cart type pour chaque mois:


```r
mois_moy &lt;- airquality %&gt;%
             group_by(Month) %&gt;%
             summarise(mean_temp = mean(Temp),
                       sd_temp   = sd(Temp))
mois_moy
# [90m# A tibble: 5 x 3[39m
#   Month mean_temp sd_temp
# [90m*[39m [3m[90m&lt;int&gt;[39m[23m     [3m[90m&lt;dbl&gt;[39m[23m   [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m     5      65.5    6.85
# [90m2[39m     6      79.1    6.60
# [90m3[39m     7      83.9    4.32
# [90m4[39m     8      84.0    6.59
# [90m5[39m     9      76.9    8.36
```

---
# D√©fi - `dplyr` et `magrittr` ![:cube]()

En utilisant le jeu de donn√©es `ChickWeight`, cr√©ez un tableau sommaire dans lequel on retrouve la diff√©rence de masse entre le maximum et le minimum de la masse enregistr√© pour chaque poussin dans l'√©tude.

Utilisez les verbes dplyr et le "pipe" `%&gt;%`.


```r
## ?ChickWeight
data(ChickWeight)
```

---
# Solution

1. Utilisez `group_by()` pour grouper le jeu de donn√©es `ChickWeight`
2. Utilisez `summarise()` pour calculer la gain de poids par groupe


```r
mass_diff &lt;- ChickWeight %&gt;%
              group_by(Chick) %&gt;%
              summarise(mass_diff = max(weight) - min(weight))
head(mass_diff)
# [90m# A tibble: 6 x 2[39m
#   Chick mass_diff
#   [3m[90m&lt;ord&gt;[39m[23m     [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m 18            4
# [90m2[39m 16           16
# [90m3[39m 15           27
# [90m4[39m 13           55
# [90m5[39m 9            58
# [90m6[39m 20           76
```

---
# D√©fi R base ![:cube]()
&lt;br&gt;
Maintenant essayez de refaire le m√™me exercice mais **seulement avec les fonctions de bases de R !** 
&lt;br&gt;
&lt;br&gt;
Prenez note qu'il existe plusieurs solutions.
&lt;br&gt;
&lt;br&gt;
.alert[Indice]: Les fonction `?aggregate()` ou `?by()` pourraient s'av√©rer utiles.

---

# D√©fi R base - Solution


```r

mass_diff_rbase &lt;- aggregate(formula = weight ~ Chick, 
                             data    = ChickWeight,
                             FUN     = function(x) weight_diff = max(x) - min(x))
names(mass_diff_rbase) &lt;- c("Chick", "weight_diff")
```


```r
# Est ce que les deux r√©sultats sont identiques (c-a-d avec et sans dplyr)

table(mass_diff_rbase ==  as.data.frame(mass_diff))
# 
# TRUE 
#  100
```

---
exclude: true

# NINJA D√©fi - `dplyr` et `magrittr` ![:cube]()

&lt;br&gt;

- En utilisant le jeu de donn√©es `ChickWeight`, cr√©ez un tableau sommaire qui indique pour chaque `diet`, la moyenne de la diff√©rence de masse entre la fin et le d√©but de l'√©tude pour chaque poussin.

- Utilisez les verbes `dplyr` et la "pipe" `%&gt;%`.

&lt;br&gt;

.alert[Indice] les fonctions `first()` et `last()` pourraient s'av√©rer utiles

---
exclude: true

# Solution ninja


```r
diet_mass &lt;- ChickWeight %&gt;%
      group_by(Diet, Chick) %&gt;%
      summarise(gain_masse = last(weight) - first(weight)) %&gt;%
      summarise(gain_moyen = mean(gain_masse))
diet_mass
# [90m# A tibble: 4 x 2[39m
#   Diet  gain_moyen
# [90m*[39m [3m[90m&lt;fct&gt;[39m[23m      [3m[90m&lt;dbl&gt;[39m[23m
# [90m1[39m 1           115.
# [90m2[39m 2           174 
# [90m3[39m 3           230.
# [90m4[39m 4           188.
```

---
# Ressources suppl√©mentaires

[Pour en savoir plus sur dplyr](http://r4ds.had.co.nz/transform.html)

[dplyr et tidyr anti-s√®che](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)


---
class: inverse, center, bottom

# Merci pour votre participation! :)

![:scale 50%](images/qcbs_logo.png)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="qcbsR-macros.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"highlightStyle": "github"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
